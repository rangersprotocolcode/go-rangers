package model

import (
	"x/src/consensus/groupsig"
	"x/src/middleware/types"
)

//StaticGroupInfo
// StaticGroupInfo is static group structure (joined to GlobalGroups after
// the group is created and add-on-chain successfully)
//创建完成的组信息
type GroupInfo struct {
	GroupID       groupsig.ID     // Group ID (can be generated by the group public key)
	GroupPK       groupsig.Pubkey // Group public key
	GroupInitInfo *GroupInitInfo  // Fixed group info after consensus

	MemberIndexMap map[string]int // Find member information by ID (member ID -> index in members)
	ParentGroupID  groupsig.ID    // Parent Group ID
	PrevGroupID    groupsig.ID    // Previous group id
}

//newSGIFromStaticGroupSummary
func NewGroupInfo(groupId groupsig.ID, groupPubkey groupsig.Pubkey, groupInitInfo *GroupInitInfo) *GroupInfo {
	groupInfo := &GroupInfo{
		GroupID:       groupId,
		GroupPK:       groupPubkey,
		GroupInitInfo: groupInitInfo,
		ParentGroupID: groupInitInfo.ParentGroupID(),
		PrevGroupID:   groupInitInfo.PreGroupID(),
	}
	groupInfo.BuildMemberIndex()
	return groupInfo
}

//newSGIFromCoreGroup
// newSGIFromCoreGroup convert the group info from chain to the StaticGroupInfo
func ConvertToGroupInfo(coreGroup *types.Group) *GroupInfo {
	groupHeader := coreGroup.Header
	mems := make([]groupsig.ID, len(coreGroup.Members))
	for i, mem := range coreGroup.Members {
		mems[i] = groupsig.DeserializeID(mem)
	}
	groupInitInfo := &GroupInitInfo{
		GroupHeader:     groupHeader,
		ParentGroupSign: *groupsig.DeserializeSign(coreGroup.Signature),
		GroupMembers:    mems,
	}
	groupInfo := &GroupInfo{
		GroupID:       groupsig.DeserializeID(coreGroup.Id),
		GroupPK:       groupsig.ByteToPublicKey(coreGroup.PubKey),
		ParentGroupID: groupsig.DeserializeID(groupHeader.Parent),
		PrevGroupID:   groupsig.DeserializeID(groupHeader.PreGroup),
		GroupInitInfo: groupInitInfo,
	}
	groupInfo.BuildMemberIndex()
	return groupInfo
}

//GetPubKey
// GetPubKey returns the public key of the group
func (groupInfo *GroupInfo) GetGroupPubKey() groupsig.Pubkey {
	return groupInfo.GroupPK
}

// GetMemberCount returns the member count
func (groupInfo *GroupInfo) GetMemberCount() int {
	return groupInfo.GroupInitInfo.MemberSize()
}

func (groupInfo *GroupInfo) GetGroupHeader() *types.GroupHeader {
	return groupInfo.GroupInitInfo.GroupHeader
}

// GetMemberID gets the member id at the specified position
func (groupInfo *GroupInfo) GetMemberID(i int) groupsig.ID {
	var m groupsig.ID
	if i >= 0 && i < len(groupInfo.MemberIndexMap) {
		m = groupInfo.GroupInitInfo.GroupMembers[i]
	}
	return m
}

//GetMembers
// GetMembers returns the member ids of the group
func (groupInfo *GroupInfo) GetGroupMembers() []groupsig.ID {
	return groupInfo.GroupInitInfo.GroupMembers
}

//GetMinerPos
// GetMinerPos get a miner's position in the group
func (groupInfo *GroupInfo) GetMemberPosition(id groupsig.ID) int {
	pos := -1
	if v, ok := groupInfo.MemberIndexMap[id.GetHexString()]; ok {
		pos = v
		// Double verification
		if !groupInfo.GroupInitInfo.GroupMembers[pos].IsEqual(id) {
			panic("double check fail!id=" + id.GetHexString())
		}
	}
	return pos
}

// MemExist check if the specified miner is belong to the group
func (groupInfo *GroupInfo) MemExist(minerId groupsig.ID) bool {
	_, ok := groupInfo.MemberIndexMap[minerId.GetHexString()]
	return ok
}

//CastQualified
// CastQualified check if the group is cast qualified at the specified height
func (groupInfo *GroupInfo) IsEffective(height uint64) bool {
	gh := groupInfo.GetGroupHeader()
	//return IsGroupWorkQualifiedAt(gh, height)
	return gh.WorkHeight <= height && height < gh.DismissHeight
}

//Dismissed
// Dismissed means whether the group has been dismissed
func (groupInfo *GroupInfo) NeedDismiss(height uint64) bool {
	//return isGroupDissmisedAt(sgi.getGroupHeader(), height)
	return groupInfo.GetGroupHeader().DismissHeight <= height
}

func (groupInfo *GroupInfo) GetReadyTimeout(height uint64) bool {
	return groupInfo.GetGroupHeader().ReadyHeight <= height
}

func (groupInfo *GroupInfo) BuildMemberIndex() {
	if groupInfo.MemberIndexMap == nil {
		groupInfo.MemberIndexMap = make(map[string]int)
	}
	for index, mem := range groupInfo.GroupInitInfo.GroupMembers {
		groupInfo.MemberIndexMap[mem.GetHexString()] = index
	}
}

//// StaticGroupInfo is static group structure (joined to GlobalGroups after
//// the group is created and add-on-chain successfully)
//type StaticGroupInfo struct {
//	GroupID     groupsig.ID                   // Group ID (can be generated by the group public key)
//	GroupPK     groupsig.Pubkey               // Group public key
//	MemIndex    map[string]int                // Find member information by ID (member ID -> index in members)
//	GInfo       *model.GroupInitInfo // Fixed group info after consensus
//	ParentID    groupsig.ID                   // Parent Group ID
//	PrevGroupID groupsig.ID                   // Previous group id
//}
//
//func newSGIFromStaticGroupSummary(gid groupsig.ID, gpk groupsig.Pubkey, group *InitedGroup) *StaticGroupInfo {
//	gInfo := group.gInfo
//	sgi := &StaticGroupInfo{
//		GroupID:     gid,
//		GroupPK:     gpk,
//		GInfo:       gInfo,
//		ParentID:    gInfo.GI.ParentID(),
//		PrevGroupID: gInfo.GI.PreGroupID(),
//	}
//	sgi.buildMemberIndex()
//	return sgi
//}
//
//// newSGIFromCoreGroup convert the group info from chain to the StaticGroupInfo
//func newSGIFromCoreGroup(coreGroup *types.Group) *StaticGroupInfo {
//	gh := coreGroup.Header
//	gis := model.ConsensusGroupInitSummary{
//		Signature: *groupsig.DeserializeSign(coreGroup.Signature),
//		GHeader:   gh,
//	}
//	mems := make([]groupsig.ID, len(coreGroup.Members))
//	for i, mem := range coreGroup.Members {
//		mems[i] = groupsig.DeserializeID(mem)
//	}
//	gInfo := &model.ConsensusGroupInitInfo{
//		GI:   gis,
//		Mems: mems,
//	}
//	sgi := &StaticGroupInfo{
//		GroupID:     groupsig.DeserializeID(coreGroup.Id),
//		GroupPK:     groupsig.ByteToPublicKey(coreGroup.PubKey),
//		ParentID:    groupsig.DeserializeID(gh.Parent),
//		PrevGroupID: groupsig.DeserializeID(gh.PreGroup),
//		GInfo:       gInfo,
//	}
//
//	sgi.buildMemberIndex()
//	return sgi
//}
//
//func (sgi *StaticGroupInfo) buildMemberIndex() {
//	if sgi.MemIndex == nil {
//		sgi.MemIndex = make(map[string]int)
//	}
//	for index, mem := range sgi.GInfo.Mems {
//		sgi.MemIndex[mem.GetHexString()] = index
//	}
//}
//
//// GetMembers returns the member ids of the group
//func (sgi *StaticGroupInfo) GetMembers() []groupsig.ID {
//	return sgi.GInfo.Mems
//}
//
//// GetMinerPos get a miner's position in the group
//func (sgi StaticGroupInfo) GetMinerPos(id groupsig.ID) int {
//	pos := -1
//	if v, ok := sgi.MemIndex[id.GetHexString()]; ok {
//		pos = v
//		// Double verification
//		if !sgi.GInfo.Mems[pos].IsEqual(id) {
//			panic("double check fail!id=" + id.GetHexString())
//		}
//	}
//	return pos
//}
//
//// GetPubKey returns the public key of the group
//func (sgi StaticGroupInfo) GetPubKey() groupsig.Pubkey {
//	return sgi.GroupPK
//}
//
//// GetMemberCount returns the member count
//func (sgi *StaticGroupInfo) GetMemberCount() int {
//	return sgi.GInfo.MemberSize()
//}
//
//// GroupConsensusInited the group completes initialization and must be
//// valid when a group has not been initialized
////
//// pk: group public key after initialization
//// id: group ID generated after initialization
//func (sgi *StaticGroupInfo) GroupConsensusInited(pk groupsig.Pubkey, id groupsig.ID) bool {
//	if sgi.GroupID.IsValid() || sgi.GroupPK.IsValid() {
//		return false
//	}
//	if !pk.IsValid() || !id.IsValid() {
//		return false
//	}
//	sgi.GroupID = id
//	sgi.GroupPK = pk
//	return true
//}
//
//func (sgi *StaticGroupInfo) getGroupHeader() *types.GroupHeader {
//	return sgi.GInfo.GI.GHeader
//}
//
//// MemExist check if the specified miner is belong to the group
//func (sgi StaticGroupInfo) MemExist(uid groupsig.ID) bool {
//	_, ok := sgi.MemIndex[uid.GetHexString()]
//	return ok
//}
//
//// GetMemberID gets the member id at the specified position
//func (sgi *StaticGroupInfo) GetMemberID(i int) groupsig.ID {
//	var m groupsig.ID
//	if i >= 0 && i < len(sgi.MemIndex) {
//		m = sgi.GInfo.Mems[i]
//	}
//	return m
//}
//
//// CastQualified check if the group is cast qualified at the specified height
//func (sgi *StaticGroupInfo) CastQualified(height uint64) bool {
//	gh := sgi.getGroupHeader()
//	return IsGroupWorkQualifiedAt(gh, height)
//}
//
//// Dismissed means whether the group has been dismissed
//func (sgi *StaticGroupInfo) Dismissed(height uint64) bool {
//	return isGroupDissmisedAt(sgi.getGroupHeader(), height)
//}
//
//func (sgi *StaticGroupInfo) GetReadyTimeout(height uint64) bool {
//	return sgi.getGroupHeader().ReadyHeight <= height
//}

// GroupConsensusInited the group completes initialization and must be
// valid when a group has not been initialized
//
// pk: group public key after initialization
// id: group ID generated after initialization
//func (groupInfo *GroupInfo) GroupConsensusInited(pk groupsig.Pubkey, id groupsig.ID) bool {
//	if sgi.GroupID.IsValid() || sgi.GroupPK.IsValid() {
//		return false
//	}
//	if !pk.IsValid() || !id.IsValid() {
//		return false
//	}
//	sgi.GroupID = id
//	sgi.GroupPK = pk
//	return true
//}
