package vrf

import (
	"io"
	"math/big"

	"com.tuntun.rocket/node/src/common"
	"com.tuntun.rocket/node/src/common/ed25519"
)

// PublicKey is the type of Ed25519 public keys.
type VRFPublicKey ed25519.PublicKey

// PrivateKey is the type of Ed25519 private keys. It implements crypto.Signer.
type VRFPrivateKey ed25519.PrivateKey

// VRFRandomValue is the output random value of VRF_Ed25519.
type VRFRandomValue []byte //RandomValueSize = 32 in bytes

// VRFProve is the output prove of VRF_Ed25519.
type VRFProve ed25519.VRFProve //ProveSize = 80 in bytes

// GenerateKey generates a public/private key pair using entropy from rand.
// If rand is nil, crypto/rand.Reader will be used.
func VRFGenerateKey(rand io.Reader) (publicKey VRFPublicKey, privateKey VRFPrivateKey, err error) {
	pk, sk, err := ed25519.GenerateKey(rand)
	return VRFPublicKey(pk), VRFPrivateKey(sk), err
}

// assume <pk, sk> were generated by ed25519.GenerateKey()
func VRFGenProve(pk VRFPublicKey, sk VRFPrivateKey, m []byte) (pi VRFProve, err error) {
	prove, err := ed25519.ECVRFProve(ed25519.PrivateKey(sk), m)
	return VRFProve(prove), err
}

func VRFProof2Hash(pi VRFProve) VRFRandomValue {
	return VRFRandomValue(pi[:32])
}

func VRFVerify(pk VRFPublicKey, pi VRFProve, m []byte) (bool, error) {
	return ed25519.ECVRFVerify(ed25519.PublicKey(pk), ed25519.VRFProve(pi), m)
}

func (vp VRFPublicKey) GetHexString() string {
	return common.ToHex(vp)
}

func Hex2VRFPublicKey(hex string) VRFPublicKey {
	return VRFPublicKey(common.FromHex(hex))
}

func (vp VRFPrivateKey) GetHexString() string {
	return common.ToHex(vp)
}

func Hex2VRFPrivateKey(hex string) VRFPrivateKey {
	return VRFPrivateKey(common.FromHex(hex))
}

func (vp VRFProve) ShortS() string {
	bi := new(big.Int).SetBytes(vp)
	hex := bi.Text(16)
	return common.ShortHex12(hex)
}

func (pi VRFProve) Big() *big.Int {
	return new(big.Int).SetBytes([]byte(pi))
}

func (rv VRFRandomValue) Big() *big.Int {
	return new(big.Int).SetBytes([]byte(rv))
}
